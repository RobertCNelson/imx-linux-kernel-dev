From b5e1932e70843be9aee59ab5ad2f24df2d305b1a Mon Sep 17 00:00:00 2001
From: Yair Shapira <yair.shapira@ti.com>
Date: Wed, 14 Nov 2012 15:10:31 +0200
Subject: [PATCH 27/33] wlcore: ACX_BA_SESSION_RX_SETUP win_size taken from sta

Now that max_rx_aggregation_subframes (BA RX win size) is stored in the
mac per active link (and not only per chip), use the link (sta) value
when passing the win_size to firmware through the ACX_BA_SESSION_RX_SETUP
command.

Signed-off-by: Yair Shapira <yair.shapira@ti.com>
---
 backports/drivers/net/wireless/ti/wlcore/acx.c     |  5 +-
 backports/drivers/net/wireless/ti/wlcore/acx.h     |  3 +-
 backports/drivers/net/wireless/ti/wlcore/main.c    | 54 +++++++++++++++++++++-
 .../drivers/net/wireless/ti/wlcore/wlcore_i.h      |  1 +
 4 files changed, 58 insertions(+), 5 deletions(-)

diff --git a/backports/drivers/net/wireless/ti/wlcore/acx.c b/backports/drivers/net/wireless/ti/wlcore/acx.c
index f28fa3b..0646c9b 100644
--- a/backports/drivers/net/wireless/ti/wlcore/acx.c
+++ b/backports/drivers/net/wireless/ti/wlcore/acx.c
@@ -1419,7 +1419,8 @@ out:
 
 /* setup BA session receiver setting in the FW. */
 int wl12xx_acx_set_ba_receiver_session(struct wl1271 *wl, u8 tid_index,
-				       u16 ssn, bool enable, u8 peer_hlid)
+				       u16 ssn, bool enable, u8 peer_hlid,
+				       u8 win_size)
 {
 	struct wl1271_acx_ba_receiver_setup *acx;
 	int ret;
@@ -1435,7 +1436,7 @@ int wl12xx_acx_set_ba_receiver_session(struct wl1271 *wl, u8 tid_index,
 	acx->hlid = peer_hlid;
 	acx->tid = tid_index;
 	acx->enable = enable;
-	acx->win_size = wl->conf.ht.rx_ba_win_size;
+	acx->win_size =	win_size;
 	acx->ssn = ssn;
 
 	ret = wlcore_cmd_configure_failsafe(wl, ACX_BA_SESSION_RX_SETUP, acx,
diff --git a/backports/drivers/net/wireless/ti/wlcore/acx.h b/backports/drivers/net/wireless/ti/wlcore/acx.h
index 954d57e..524aea4 100644
--- a/backports/drivers/net/wireless/ti/wlcore/acx.h
+++ b/backports/drivers/net/wireless/ti/wlcore/acx.h
@@ -1112,7 +1112,8 @@ int wl1271_acx_set_ht_information(struct wl1271 *wl,
 int wl12xx_acx_set_ba_initiator_policy(struct wl1271 *wl,
 				       struct wl12xx_vif *wlvif);
 int wl12xx_acx_set_ba_receiver_session(struct wl1271 *wl, u8 tid_index,
-				       u16 ssn, bool enable, u8 peer_hlid);
+				       u16 ssn, bool enable, u8 peer_hlid,
+				       u8 win_size);
 int wl12xx_acx_tsf_info(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 			u64 *mactime);
 int wl1271_acx_ps_rx_streaming(struct wl1271 *wl, struct wl12xx_vif *wlvif,
diff --git a/backports/drivers/net/wireless/ti/wlcore/main.c b/backports/drivers/net/wireless/ti/wlcore/main.c
index e55f60b..bcf1ac9 100644
--- a/backports/drivers/net/wireless/ti/wlcore/main.c
+++ b/backports/drivers/net/wireless/ti/wlcore/main.c
@@ -5285,6 +5285,48 @@ out:
 	return ret;
 }
 
+int wlcore_rx_ba_max_subframes(struct wl1271 *wl, u8 hlid)
+{
+	struct wl12xx_vif *wlvif;
+	struct ieee80211_vif *vif;
+	struct ieee80211_sta *sta;
+
+	int win_size;
+
+	wlvif = wl->links[hlid].wlvif;
+	if (unlikely(!wlvif)) {
+		win_size = -EINVAL;
+		wl1271_error("wlvif for hlid %d is null", hlid);
+		goto out;
+	}
+
+	vif = wl12xx_wlvif_to_vif(wlvif);
+	if (unlikely(!vif)) {
+		win_size = -EINVAL;
+		wl1271_error("vif for hlid %d is null", hlid);
+		goto out;
+	}
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta(vif, wlvif->bss_type != BSS_TYPE_AP_BSS ?
+					   vif->bss_conf.bssid :
+					   wl->links[hlid].addr);
+	if (unlikely(!sta)) {
+		win_size = -EINVAL;
+		wl1271_error("sta for hlid %d is null", hlid);
+
+		rcu_read_unlock();
+		goto out;
+	}
+
+	win_size = sta->max_rx_aggregation_subframes;
+	rcu_read_unlock();
+
+out:
+	return win_size;
+}
+EXPORT_SYMBOL_GPL(wlcore_rx_ba_max_subframes);
+
 static int wl1271_op_ampdu_action(struct ieee80211_hw *hw,
 				  struct ieee80211_vif *vif,
 				  enum ieee80211_ampdu_mlme_action action,
@@ -5295,6 +5337,7 @@ static int wl1271_op_ampdu_action(struct ieee80211_hw *hw,
 	struct wl12xx_vif *wlvif = wl12xx_vif_to_data(vif);
 	int ret;
 	u8 hlid, *ba_bitmap;
+	int win_size;
 
 	wl1271_debug(DEBUG_MAC80211, "mac80211 ampdu action %d tid %d", action,
 		     tid);
@@ -5351,8 +5394,15 @@ static int wl1271_op_ampdu_action(struct ieee80211_hw *hw,
 			break;
 		}
 
+		win_size = wlcore_rx_ba_max_subframes(wl, hlid);
+		if (win_size < 0) {
+			ret = -EINVAL;
+			wl1271_error("cannot get link rx_ba_max_subframes");
+			break;
+		}
+
 		ret = wl12xx_acx_set_ba_receiver_session(wl, tid, *ssn, true,
-							 hlid);
+							 hlid, win_size);
 		if (!ret) {
 			*ba_bitmap |= BIT(tid);
 			wl->ba_rx_session_count++;
@@ -5373,7 +5423,7 @@ static int wl1271_op_ampdu_action(struct ieee80211_hw *hw,
 		}
 
 		ret = wl12xx_acx_set_ba_receiver_session(wl, tid, 0, false,
-							 hlid);
+							 hlid, 0);
 		if (!ret) {
 			*ba_bitmap &= ~BIT(tid);
 			wl->ba_rx_session_count--;
diff --git a/backports/drivers/net/wireless/ti/wlcore/wlcore_i.h b/backports/drivers/net/wireless/ti/wlcore/wlcore_i.h
index 298fbd1..d910a1b 100644
--- a/backports/drivers/net/wireless/ti/wlcore/wlcore_i.h
+++ b/backports/drivers/net/wireless/ti/wlcore/wlcore_i.h
@@ -541,6 +541,7 @@ struct wl12xx_rx_filter *wl1271_rx_filter_alloc(void);
 int wl1271_rx_filter_get_fields_size(struct wl12xx_rx_filter *filter);
 void wl1271_rx_filter_flatten_fields(struct wl12xx_rx_filter *filter,
 				     u8 *buf);
+int wlcore_rx_ba_max_subframes(struct wl1271 *wl, u8 hlid);
 
 #define JOIN_TIMEOUT 5000 /* 5000 milliseconds to join */
 
-- 
2.5.1

